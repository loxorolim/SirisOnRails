set Z;
 set Y;
 param A{r in Z, m in Y} default 0, binary;
param B{r in Z} default 1, integer;
 var Route{m in Y}, binary;
 minimize cost: sum{m in Y} Route[m];
 subject to covers{r in Z}: sum{m in Y} A[r,m]*Route[m]>=B[r];
 solve; 
 printf {m in Y:  Route[m] == 1} "%s ", m > "C:/Users/Guilherme/Documents/GitHub/SirisOnRails/Results.txt";
 data;
set Z:= Z0 Z1 Z2 Z3 Z4 Z5 Z6 Z7 Z8 Z9 Z10 Z11 Z12 Z13 Z14 Z15 Z16 Z17 Z18 Z19 Z20 ;
set Y:= Y0 Y1 Y2 Y3 Y4 Y5 Y6 Y7 Y8 Y9 Y10 Y11 ;
param A := 
[Z0,Y0] 1[Z0,Y4] 1[Z0,Y5] 1[Z0,Y6] 1[Z0,Y7] 1[Z0,Y8] 1[Z1,Y0] 1[Z1,Y4] 1[Z1,Y5] 1[Z1,Y6] 1[Z1,Y7] 1[Z1,Y8] 1[Z2,Y0] 1[Z2,Y4] 1[Z2,Y5] 1[Z2,Y6] 1[Z2,Y7] 1[Z2,Y8] 1[Z3,Y0] 1[Z3,Y1] 1[Z3,Y4] 1[Z3,Y5] 1[Z3,Y6] 1[Z3,Y7] 1[Z3,Y8] 1[Z4,Y1] 1[Z4,Y2] 1[Z4,Y5] 1[Z4,Y6] 1[Z5,Y1] 1[Z5,Y2] 1[Z5,Y3] 1[Z5,Y6] 1[Z6,Y2] 1[Z6,Y3] 1[Z7,Y1] 1[Z7,Y2] 1[Z7,Y3] 1[Z7,Y6] 1[Z8,Y1] 1[Z8,Y2] 1[Z8,Y3] 1[Z8,Y5] 1[Z8,Y6] 1[Z9,Y0] 1[Z9,Y1] 1[Z9,Y2] 1[Z9,Y4] 1[Z9,Y5] 1[Z9,Y6] 1[Z9,Y7] 1[Z9,Y8] 1[Z10,Y0] 1[Z10,Y1] 1[Z10,Y4] 1[Z10,Y5] 1[Z10,Y6] 1[Z10,Y7] 1[Z10,Y8] 1[Z11,Y0] 1[Z11,Y4] 1[Z11,Y5] 1[Z11,Y6] 1[Z11,Y7] 1[Z11,Y8] 1[Z12,Y0] 1[Z12,Y1] 1[Z12,Y2] 1[Z12,Y5] 1[Z12,Y6] 1[Z12,Y7] 1[Z13,Y9] 1[Z13,Y10] 1[Z14,Y9] 1[Z14,Y10] 1[Z15,Y9] 1[Z15,Y10] 1[Z16,Y9] 1[Z16,Y10] 1[Z17,Y9] 1[Z17,Y10] 1[Z18,Y11] 1[Z19,Y11] 1[Z20,Y1] 1[Z20,Y2] 1[Z20,Y6] 1
;
param B := 

;
end;
